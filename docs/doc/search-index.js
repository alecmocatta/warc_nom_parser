var searchIndex = {};
searchIndex['warc_parser'] = {"items":[[0,"","warc_parser","",null,null],[3,"Record","","The WArc `Record` struct",null,null],[12,"headers","","WArc headers",0,null],[12,"content","","Content for call in a raw format",0,null],[5,"record","","Parses one record and returns an IResult from nom",null,null],[5,"records","","",null,null],[11,"fmt","","",0,{"inputs":[{"name":"record"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[3,"Record"]]};
searchIndex['nom'] = {"items":[[0,"","nom","Nom, eating data byte by byte",null,null],[3,"AccReader","","",null,null],[3,"FileProducer","","Can produce data from a file",null,null],[3,"MemProducer","","Can parse data from an already in memory byte array",null,null],[3,"ReadProducer","","Can produce data from a struct implementing Read",null,null],[3,"Stepper","","",null,null],[4,"ErrorCode","","",null,null],[13,"Tag","","",0,null],[13,"MapRes","","",0,null],[13,"MapOpt","","",0,null],[13,"Alt","","",0,null],[13,"IsNot","","",0,null],[13,"IsA","","",0,null],[13,"Filter","","",0,null],[13,"SeparatedList","","",0,null],[13,"SeparatedNonEmptyList","","",0,null],[13,"Many1","","",0,null],[13,"Count","","",0,null],[13,"TakeUntilAndConsume","","",0,null],[13,"TakeUntil","","",0,null],[13,"TakeUntilEitherAndConsume","","",0,null],[13,"TakeUntilEither","","",0,null],[13,"LengthValue","","",0,null],[13,"TagClosure","","",0,null],[13,"Alpha","","",0,null],[13,"Digit","","",0,null],[13,"AlphaNumeric","","",0,null],[13,"Space","","",0,null],[13,"MultiSpace","","",0,null],[13,"LengthValueFn","","",0,null],[13,"Eof","","",0,null],[13,"ExprOpt","","",0,null],[13,"ExprRes","","",0,null],[13,"CondReduce","","",0,null],[4,"Err","","",null,null],[13,"Code","","",1,null],[13,"Node","","",1,null],[13,"Position","","",1,null],[13,"NodePosition","","",1,null],[4,"Needed","","",null,null],[13,"Unknown","","",2,null],[13,"Size","","",2,null],[4,"IResult","","Holds the result of parsing functions",null,null],[13,"Done","","",3,null],[13,"Error","","",3,null],[13,"Incomplete","","",3,null],[4,"ProducerState","","Holds the data producer's current state",null,null],[13,"Eof","","",4,null],[13,"Continue","","",4,null],[13,"Data","","",4,null],[13,"ProducerError","","",4,null],[4,"StepperState","","",null,null],[13,"Eof","","",5,null],[13,"Value","","",5,null],[13,"ProducerError","","",5,null],[13,"Continue","","",5,null],[13,"ParserError","","",5,null],[4,"ConsumerState","","Holds the current state of the consumer",null,null],[13,"Await","","",6,null],[13,"Seek","","",6,null],[13,"Incomplete","","",6,null],[13,"ConsumerDone","","",6,null],[13,"ConsumerError","","",6,null],[5,"error_to_list","","",null,{"inputs":[{"name":"err"}],"output":{"name":"vec"}}],[5,"compare_error_paths","","",null,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[5,"add_error_pattern","","",null,{"inputs":[{"name":"hashmap"},{"name":"iresult"},{"name":"str"}],"output":{"name":"bool"}}],[5,"slice_to_offsets","","",null,null],[5,"prepare_errors","","",null,null],[5,"print_error","","",null,null],[5,"generate_colors","","",null,{"inputs":[{"name":"vec"}],"output":{"name":"hashmap"}}],[5,"code_from_offset","","",null,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"option"}}],[5,"reset_color","","",null,{"inputs":[{"name":"vec"}],"output":null}],[5,"write_color","","",null,{"inputs":[{"name":"vec"},{"name":"u8"}],"output":null}],[5,"print_codes","","",null,{"inputs":[{"name":"hashmap"},{"name":"hashmap"}],"output":{"name":"string"}}],[5,"print_offsets","","",null,null],[5,"tag_cl","","",null,null],[5,"print","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"begin","","",null,null],[5,"not_line_ending","","",null,null],[5,"line_ending","","Recognizes a line feed",null,null],[5,"is_alphabetic","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_space","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"alpha","","Recognizes lowercase and uppercase alphabetic characters: a-zA-Z",null,null],[5,"digit","","Recognizes numerical characters: 0-9",null,null],[5,"alphanumeric","","Recognizes numerical and alphabetic characters: 0-9a-zA-Z",null,null],[5,"space","","Recognizes spaces and tabs",null,null],[5,"multispace","","Recognizes spaces, tabs, carriage returns and line feeds",null,null],[5,"sized_buffer","","",null,null],[5,"length_value","","",null,null],[5,"be_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"be_u16","","Recognizes big endian unsigned 2 bytes integer",null,null],[5,"be_u32","","Recognizes big endian unsigned 4 bytes integer",null,null],[5,"be_u64","","Recognizes big endian unsigned 8 bytes integer",null,null],[5,"be_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"be_i16","","Recognizes big endian signed 2 bytes integer",null,null],[5,"be_i32","","Recognizes big endian signed 4 bytes integer",null,null],[5,"be_i64","","Recognizes big endian signed 8 bytes integer",null,null],[5,"le_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"le_u16","","Recognizes little endian unsigned 2 bytes integer",null,null],[5,"le_u32","","Recognizes little endian unsigned 4 bytes integer",null,null],[5,"le_u64","","Recognizes little endian unsigned 8 bytes integer",null,null],[5,"le_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"le_i16","","Recognizes little endian signed 2 bytes integer",null,null],[5,"le_i32","","Recognizes little endian signed 4 bytes integer",null,null],[5,"le_i64","","Recognizes little endian signed 8 bytes integer",null,null],[5,"be_f32","","Recognizes big endian 4 bytes floating point number",null,null],[5,"be_f64","","Recognizes big endian 8 bytes floating point number",null,null],[5,"eof","","Recognizes empty input buffers",null,null],[11,"clone","","",1,{"inputs":[{"name":"err"}],"output":{"name":"err"}}],[11,"eq","","",1,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"err"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"needed"}],"output":{"name":"needed"}}],[11,"eq","","",2,{"inputs":[{"name":"needed"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"needed"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"needed"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"iresult"}}],[11,"eq","","",3,{"inputs":[{"name":"iresult"},{"name":"iresult"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"iresult"},{"name":"iresult"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"iresult"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_done","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"is_err","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"is_incomplete","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"new","","",7,{"inputs":[{"name":"accreader"},{"name":"r"}],"output":{"name":"accreader"}}],[11,"with_capacity","","",7,{"inputs":[{"name":"accreader"},{"name":"usize"},{"name":"r"}],"output":{"name":"accreader"}}],[11,"get_ref","","Gets a reference to the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"get_mut","","Gets a mutable reference to the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"into_inner","","Unwraps this `AccReader`, returning the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"reset_buffer_position","","",7,{"inputs":[{"name":"accreader"}],"output":null}],[11,"current_slice","","",7,null],[11,"capacity","","",7,{"inputs":[{"name":"accreader"}],"output":{"name":"usize"}}],[11,"read","","",7,null],[11,"fill_buf","","",7,{"inputs":[{"name":"accreader"}],"output":{"name":"result"}}],[11,"consume","","",7,{"inputs":[{"name":"accreader"},{"name":"usize"}],"output":null}],[11,"eq","","",4,{"inputs":[{"name":"producerstate"},{"name":"producerstate"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"producerstate"},{"name":"producerstate"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"producerstate"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",8,{"inputs":[{"name":"fileproducer"},{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[11,"produce","","",8,{"inputs":[{"name":"fileproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",8,{"inputs":[{"name":"fileproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"new","","",9,null],[11,"produce","","",9,{"inputs":[{"name":"memproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",9,{"inputs":[{"name":"memproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"new","","",10,{"inputs":[{"name":"readproducer"},{"name":"t"},{"name":"usize"}],"output":{"name":"readproducer"}}],[11,"produce","","",10,{"inputs":[{"name":"readproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",10,{"inputs":[{"name":"readproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"eq","","",5,{"inputs":[{"name":"stepperstate"},{"name":"stepperstate"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"stepperstate"},{"name":"stepperstate"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"stepperstate"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",11,{"inputs":[{"name":"stepper"},{"name":"t"}],"output":{"name":"stepper"}}],[11,"step","","",11,{"inputs":[{"name":"stepper"},{"name":"f"}],"output":{"name":"stepperstate"}}],[11,"clone","","",6,{"inputs":[{"name":"consumerstate"}],"output":{"name":"consumerstate"}}],[11,"eq","","",6,{"inputs":[{"name":"consumerstate"},{"name":"consumerstate"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"consumerstate"},{"name":"consumerstate"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"consumerstate"},{"name":"formatter"}],"output":{"name":"result"}}],[8,"HexDisplay","","",null,null],[10,"offset","","",12,null],[10,"to_hex","","Converts the value of `self` to a hex value, returning the owned\nstring.",12,{"inputs":[{"name":"hexdisplay"},{"name":"usize"}],"output":{"name":"string"}}],[10,"to_hex_from","","",12,{"inputs":[{"name":"hexdisplay"},{"name":"usize"},{"name":"usize"}],"output":{"name":"string"}}],[8,"AsBytes","","",null,null],[10,"as_bytes","","",13,null],[8,"GetInput","","",null,null],[10,"remaining_input","","",14,{"inputs":[{"name":"getinput"}],"output":{"name":"option"}}],[8,"GetOutput","","",null,null],[10,"output","","",15,{"inputs":[{"name":"getoutput"}],"output":{"name":"option"}}],[8,"Producer","","A producer implements the produce method, currently working with u8 arrays",null,null],[10,"produce","","",16,{"inputs":[{"name":"producer"}],"output":{"name":"producerstate"}}],[10,"seek","","",16,{"inputs":[{"name":"producer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[8,"Consumer","","Implement the consume method, taking a byte array as input and returning a consumer state",null,null],[10,"consume","","",17,null],[10,"failed","","",17,{"inputs":[{"name":"consumer"},{"name":"u32"}],"output":null}],[10,"end","","",17,{"inputs":[{"name":"consumer"}],"output":null}],[11,"run","","",17,{"inputs":[{"name":"consumer"},{"name":"producer"}],"output":null}],[14,"dbg!","","Prints a message if the parser fails",null,null],[14,"dbg_dmp!","","Prints a message and the input if the parser fails",null,null],[14,"closure!","","Wraps a parser in a closure",null,null],[14,"named!","","Makes a function from a parser combination",null,null],[14,"call!","","Used to wrap common expressions and function as macros",null,null],[14,"apply!","","",null,null],[14,"error!","","Prevents backtracking if the child parser fails",null,null],[14,"tag!","","`tag!(&[T]: nom::AsBytes) => &[T] -> IResult<&[T], &[T]>`\ndeclares a byte array as a suite to recognize",null,null],[14,"flat_map!","","`flat_map!(R -> IResult<R,S>, S -> IResult<S,T>) => R -> IResult<R, T>`",null,null],[14,"map!","","`map!(I -> IResult<I,O>, O -> P) => I -> IResult<I, P>`\nmaps a function on the result of a parser",null,null],[14,"map_impl!","","Internal parser, do not use directly",null,null],[14,"map_res!","","`map_res!(I -> IResult<I,O>, O -> Result<P>) => I -> IResult<I, P>`\nmaps a function returning a Result on the output of a parser",null,null],[14,"map_res_impl!","","Internal parser, do not use directly",null,null],[14,"map_opt!","","`map_res!(I -> IResult<I,O>, O -> Option<P>) => I -> IResult<I, P>`\nmaps a function returning an Option on the output of a parser",null,null],[14,"map_opt_impl!","","Internal parser, do not use directly",null,null],[14,"expr_res!","","`expr_res!(Result<E,O>) => I -> IResult<I, O>`\nevaluate an expression that returns a Result<T,E> and returns a IResult::Done(I,T) if Ok",null,null],[14,"expr_opt!","","`expr_opt!(Option<O>) => I -> IResult<I, O>`\nevaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Ok",null,null],[14,"chain!","","`chain!(I->IResult<I,A> ~ I->IResult<I,B> ~ ... I->IResult<I,X> , || { return O } ) => I -> IResult<I, O>`\nchains parsers and assemble the results through a closure",null,null],[14,"chaining_parser!","","Internal parser, do not use directly",null,null],[14,"alt!","","`alt!(I -> IResult<I,O> | I -> IResult<I,O> | ... | I -> IResult<I,O> ) => I -> IResult<I, O>`\ntry a list of parser, return the result of the first successful one",null,null],[14,"alt_parser!","","Internal parser, do not use directly",null,null],[14,"is_not!","","`is_not!(&[T:AsBytes]) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes that do not appear in the provided array",null,null],[14,"is_a!","","`is_a!(&[T]) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes that appear in the provided array",null,null],[14,"filter!","","`filter!(&[T] -> bool) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes until the provided function fails.",null,null],[14,"opt!","","`opt!(I -> IResult<I,O>) => I -> IResult<I, Option<O>>`\nmake the underlying parser optional",null,null],[14,"opt_res!","","`opt_res!(I -> IResult<I,O>) => I -> IResult<I, Result<nom::Err,O>>`\nmake the underlying parser optional",null,null],[14,"cond!","","`cond!(bool, I -> IResult<I,O>) => I -> IResult<I, Option<O>>`\nConditional combinator",null,null],[14,"cond_reduce!","","`cond_reduce!(bool, I -> IResult<I,O>) => I -> IResult<I, O>`\nConditional combinator with error",null,null],[14,"peek!","","`peek!(I -> IResult<I,O>) => I -> IResult<I, O>`\nreturns a result without consuming the input",null,null],[14,"tap!","","`tap!(name: I -> IResult<I,O> => { block }) => I -> IResult<I, O>`\nallows access to the parser's result without affecting it",null,null],[14,"pair!","","`pair!(I -> IResult<I,O>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>`\npair(X,Y), returns (x,y)",null,null],[14,"separated_pair!","","`separated_pair!(I -> IResult<I,O>, I -> IResult<I, T>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>`\nseparated_pair(X,sep,Y) returns (x,y)",null,null],[14,"separated_pair1!","","Internal parser, do not use directly",null,null],[14,"separated_pair2!","","Internal parser, do not use directly",null,null],[14,"preceded!","","`preceded!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, O>`\npreceded(opening, X) returns X",null,null],[14,"terminated!","","`terminated!(I -> IResult<I,O>, I -> IResult<I,T>) => I -> IResult<I, O>`\nterminated(X, closing) returns X",null,null],[14,"delimited!","","`delimited!(I -> IResult<I,T>, I -> IResult<I,O>, I -> IResult<I,U>) => I -> IResult<I, O>`\ndelimited(opening, X, closing) returns X",null,null],[14,"delimited1!","","Internal parser, do not use directly",null,null],[14,"delimited2!","","Internal parser, do not use directly",null,null],[14,"separated_list!","","`separated_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nseparated_list(sep, X) returns Vec<X>",null,null],[14,"separated_nonempty_list!","","`separated_nonempty_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nseparated_nonempty_list(sep, X) returns Vec<X>",null,null],[14,"many0!","","`many0!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nApplies the parser 0 or more times and returns the list of results in a Vec",null,null],[14,"many1!","","`many1!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nApplies the parser 1 or more times and returns the list of results in a Vec",null,null],[14,"count!","","`count!(I -> IResult<I,O>, nb) => I -> IResult<I, Vec<O>>`\nApplies the child parser a specified number of times",null,null],[14,"count_fixed!","","`count_fixed!(I -> IResult<I,O>, nb) => I -> IResult<I, [O; nb]>`\nApplies the child parser a fixed number of times and returns a fixed size array",null,null],[14,"take!","","`take!(nb) => &[T] -> IResult<&[T], &[T]>`\ngenerates a parser consuming the specified number of bytes",null,null],[14,"take_str!","","`take!(nb) => &[T] -> IResult<&[T], &str>`\nsame as take! but returning a &str",null,null],[14,"take_until_and_consume!","","`take_until_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>`\ngenerates a parser consuming bytes until the specified byte sequence is found",null,null],[14,"take_until!","","`take_until!(tag) => &[T] -> IResult<&[T], &[T]>`",null,null],[14,"take_until_either_and_consume!","","`take_until_either_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>`",null,null],[14,"take_until_either!","","`take_until_either!(tag) => &[T] -> IResult<&[T], &[T]>`",null,null],[14,"length_value!","","`length_value!(I -> IResult<I, nb>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\ngets a number from the first parser, then applies the second parser that many times",null,null],[14,"pusher!","","Prepares a parser function for a push pipeline",null,null],[14,"u16!","","if parameter is true, parse a big endian u16 integer,\notherwise a little endian u16 integer",null,null],[14,"u32!","","if parameter is true, parse a big endian u32 integer,\notherwise a little endian u32 integer",null,null],[14,"u64!","","if parameter is true, parse a big endian u64 integer,\notherwise a little endian u64 integer",null,null],[14,"i16!","","if parameter is true, parse a big endian i16 integer,\notherwise a little endian i16 integer",null,null],[14,"i32!","","if parameter is true, parse a big endian i32 integer,\notherwise a little endian i32 integer",null,null],[14,"i64!","","if parameter is true, parse a big endian i64 integer,\notherwise a little endian i64 integer",null,null],[11,"run","","",17,{"inputs":[{"name":"consumer"},{"name":"producer"}],"output":null}]],"paths":[[4,"ErrorCode"],[4,"Err"],[4,"Needed"],[4,"IResult"],[4,"ProducerState"],[4,"StepperState"],[4,"ConsumerState"],[3,"AccReader"],[3,"FileProducer"],[3,"MemProducer"],[3,"ReadProducer"],[3,"Stepper"],[8,"HexDisplay"],[8,"AsBytes"],[8,"GetInput"],[8,"GetOutput"],[8,"Producer"],[8,"Consumer"]]};
initSearch(searchIndex);
